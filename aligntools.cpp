//Program to calculate predicted sigma values for loci in a model system, where data is generated by a sampling process
//This code uses a deterministic method to run the underlying population distribution, and samples it at low frequency

#include <iostream>
#include <sstream>
#include <vector>
#include <list>
#include <deque>
using namespace std;

#include "aligntools.h"
#include "distance_matrix.h"
#include "diversity.h"
#include "editing.h"
#include "io.h"
#include "rgen.h"
#include "timesplit.h"
#include "utilities.h"
#include <Eigen/Dense>

int main(int argc, const char **argv){

    //Code to read in an alignment.
    //Identifies variants and will make covariance matrix between these sites.
    
    //Initialise random number generator
    
	run_params p;
	GetParameters(p,argc,argv);
    p.seed=(int) time(NULL);
    gsl_rng_env_setup();
    gsl_rng *rgen = gsl_rng_alloc (gsl_rng_taus);
    gsl_rng_set (rgen, p.seed);
    
    vector<string> seqs;
    vector<string> names;
    ReadFastaAli(p,seqs,names);
    CheckBaseCase(seqs);
    
    if (p.method.compare("DistanceMatrix")==0) {
        vector< vector<int> > seqdists;
        MakeDistanceMatrix (p,1,seqs,names,seqdists);
        return 0;
    }
    
    if (p.method.compare("FilterPdiff")==0) {
        FilterPDiff (p,seqs,names,rgen);
        /*
        string all_consensus;
        FindConsensus(all_consensus,seqs);
        vector<sparseseq> variants;
        FindSVariants (variants,all_consensus,seqs);
        cout << variants.size() << "\n";
        
        cout << variants[0].locus.size() << "\n";
        
        
        cout << "Length " << seqs[0].length() << "\n";
        
        p.qq_cut=0.01;
        int threshold=seqs[0].length()*p.qq_cut;
        //Keep track of sequences
        vector<int> done;
        vector<int> index;
        for (int i=0;i<seqs.size();i++) {
            done.push_back(0);
        }
        
        vector<int> sample;
        int donezero=1;
        while (donezero==1) {
            index.clear();
            for (int i=0;i<done.size();i++) {
                if (done[i]==0) {
                    index.push_back(i);
                }
            }
            cout << "Index size " << index.size() << "\n";
            int selected=floor(gsl_rng_uniform(rgen)*index.size()+0.5)-1;
            selected=index[selected];
            done[selected]=1;
            sample.push_back(selected);
            
            //Find everything within threshold and remove
            for (int i=0;i<variants.size();i++) {
                if (done[i]==0) {
                    //Find unique difference positions between selected and i
                    vector<int> uniq;
                    for (int k=0;k<variants[i].locus.size();k++) {
                        uniq.push_back(variants[i].locus[k]);
                    }
                    for (int k=0;k<variants[selected].locus.size();k++) {
                        uniq.push_back(variants[selected].locus[k]);
                    }
                    sort(uniq.begin(),uniq.end());
                    uniq.erase(unique(uniq.begin(),uniq.end()),uniq.end());
                    
                    //Run comparison over uniq positions
                    int dist=0;
                    int kk=0;
                    while (kk<uniq.size()&&dist<threshold) {
                        if (seqs[i][uniq[kk]]=='A'||seqs[i][uniq[kk]]=='C'||seqs[i][uniq[kk]]=='G'||seqs[i][uniq[kk]]=='T') {
                            if (seqs[selected][uniq[kk]]=='A'||seqs[selected][uniq[kk]]=='C'||seqs[selected][uniq[kk]]=='G'||seqs[selected][uniq[kk]]=='T') {
                                if (seqs[i][uniq[kk]]!=seqs[selected][uniq[kk]]) {
                                    dist++;
                                }
                            }
                        }
                        kk++;
                    }
                    if (dist<threshold) {
                        done[i]=1;
                    }
                }
            }
            donezero=0;
            for (int i=0;i<done.size();i++) {
                if (done[i]==0) {
                    donezero=1;
                    break;
                }
            }
            
            
        }
        sort(sample.begin(),sample.end());
        sample.erase(unique(sample.begin(),sample.end()),sample.end());

        cout << "Sample\n";
        for (int i=0;i<sample.size();i++) {
            cout << sample[i] << " ";
        }
        cout << "\n";
        OutputAlignmentSFiltered (names,seqs,sample);
        
        */
        
        return 0;
    }

    
    //Get alignment statistics
    vector<site> ali_stats;
    GetAliStats (seqs,ali_stats);
    
    //Consensus sequence
    vector<string> consensus;
    GetConsensus(ali_stats,consensus);
    int seq_length=consensus.size();
  

    //Next step - variant positions
    vector<int> var_positions;
    FindVariants (ali_stats,var_positions);
    
    cout << "Positions " << var_positions.size() << " " << consensus.size() << "\n";
    
    if (p.method.compare("FilterSiteQ")==0) {
        FilterAlignmentQ (p,ali_stats,seqs,names);
        return 0;
    }

    
    if (p.method.compare("Diversity")==0) {
        GetPiDiversity (p,seq_length,seqs,names);
        return 0;
    }
    
    if (p.method.compare("Random")==0) {
        
        GenerateRandomSequences (p,seq_length,consensus,var_positions,ali_stats,seqs,rgen);
        
    } else if (p.method.compare("TimedFreqs")==0) {
        
        GetTDNucleotideCounts (p,consensus,var_positions,ali_stats,seqs);
        
        
    } else {
        cout << "Instructions:\n";
        cout << "./run_align DistanceMatrix <flags> : Calculates matrix of distances between sequences.\n";
        cout << "./run_align Diversity <flags> : Calculates pi diversity for sequences in the alignment.\n";
        cout << "./run_align Random <flags> : Generates random sequences.\n";
        cout << "./run_align FilterSiteQ <flags> : Generates random sequences.\n";
        cout << "Flags are:\n";
        cout << " --q_cut <frequency> : [Default 0.1] Require this fraction of sites to have an {A,C,G,T} nucleotide\n";
        cout << "Output to Output_alignment.fa\n";
        cout << "./run_align TimedFreqs <flags> : Separates sequences in an alignment by time and produces records of variant frequency over time.\n";
        cout << "Official flags are:\n";
        cout << " --ali_file <file> : Multiple sequence alignment file in .fasta format\n";
        cout << "In Random:\n";
        cout << " --generate <number> : Number of random sequences to generate\n";
        cout << " --verb <number> : Write out variant details to file\n";
        cout << " --output <type> : Output format for random files:\n";
        cout << "       Sparse: [Default] Output positions of variants w.r.t. consensus\n";
        cout << "       FASTA: Output as .fasta file format\n";
        cout << "       Binary: Output as binary string at variant positions\n";
        cout << "In TimeFreqs:\n";
        cout << " --q_cut <frequency> : [Default 0.1] Minimum minor allele frequency to report\n";
        cout << " --n_cut <value> : [Default 10] Minimum read depth when calling variant allele\n";
        cout << " --n_reps <type> : [Default 1] Minimum number of times variant observed at given frequency and read depth:\n";

    }
    
    return 0;
    
            
    return 0;
}
	
	
